manutencao-preditiva/
├── backend/
│   └── [todos os arquivos acima]
├── frontend/
│   └── [React app]
├── README.md


backend/
├── Dockerfile
├── docker-compose.yml
├── .env
├── server.js
├── package.json
├── config/
│   └── db.js
├── models/
│   └── SensorData.js
│   └── Alert.js
├── modbus/
│   └── client.js
│   └── poller.js
├── controllers/
│   └── sensorController.js
│   └── alertController.js
├── routes/
│   └── sensorRoutes.js
│   └── alertRoutes.js
├── utils/
│   └── thresholds.js
│   └── logger.js




Structured Text para OpenPLC

(*
  Programa: TemperatureMonitor
  Plataforma: OpenPLC (IEC 61131-3)
  
  Descrição:
  Este programa monitora a temperatura recebida via Modbus TCP no registrador de entrada %IW0,
  proveniente de um sensor conectado ao ESP32. A leitura é feita em décimos de grau Celsius
  (ex.: 301 = 30,1 °C). Um temporizador TON de 5 segundos é utilizado para evitar alarmes
  causados por flutuações momentâneas (anti-ruído). Caso a temperatura ultrapasse o limite
  configurável em %MW10 (padrão: 300 = 30,0 °C) por mais de 5 segundos, um alarme é ativado
  e permanece latched (travado) até que seja manualmente resetado via entrada digital %IX0.0.
  
  A saída de alarme é acionada em %QX0.0, podendo ser conectada a uma sirene, luz de advertência
  ou outro atuador.
*)


PROGRAM DHTMonitor
VAR
    TEMP_X10 AT %IW0 : INT;           // Temperatura x10 (ex.: 301 = 30.1°C)
    HUMID_X10 AT %IW1 : INT;          // Umidade x10 (ex.: 650 = 65.0%)
    LIMIT_TEMP AT %MW10 : INT := 300; // Limite temperatura x10
    LIMIT_HUMID AT %MW11 : INT := 700;// Limite umidade x10

    RESET_ALARM AT %IX0.0 : BOOL;
    ALARM AT %QX0.0 : BOOL;
    LATCH : BOOL;
    TON1 : TON;
END_VAR

TON1(IN := (TEMP_X10 >= LIMIT_TEMP) OR (HUMID_X10 >= LIMIT_HUMID), PT := T#5s);

IF TON1.Q THEN
    LATCH := TRUE;
END_IF;

IF RESET_ALARM THEN
    LATCH := FALSE;
END_IF;

ALARM := LATCH;
END_PROGRAM





Ladder equivalente para OpenPLC

Réplica do ST acima. Você pode montar no editor Ladder em três redes.



    Rede 1 Comparação com limite

    Contatos: TEMP_X10 e LIMIT_X10 em um bloco de comparação GE (>=).

    Saída: GE_TMP (contato interno).


    [TEMP_X10] --(GE >=)-- [LIMIT_X10] ----( )---- GE_TMP


    Rede 2 Temporizador TON de 5s

    Entrada: GE_TMP

    Bloco: TON1 (IN := GE_TMP, PT := 5s)

    Saída: TON1.Q


    GE_TMP ----[ TON 5s ]---- TON1.Q


    Rede 3 Latch do alarme com reset

    Seta (S) quando TON1.Q = 1

    Reseta (R) quando RESET_ALARM = 1

    Coil final: ALARM

    Espelho em word: ALARM_WORD := 1 quando ALARM, senão 0 (pode ser feito via 
    MOVE/SEL em outra rede se preferir)


         +----[ S ]----+
    TON1.Q --|             |----( LATCH )----( ALARM )
    RESET ----+----[ R ]---+

    ALARM ----[SEL/MOVE]---- ALARM_WORD (1 quando ALARM, 0 caso contrário)


    Dica rápida:

    Se preferir anti-ruído mais robusto, some uma histerese via dois limites: LIMIT_HIGH_X10 e LIMIT_LOW_X10, com set pelo alto e 
    reset pelo baixo.


   
   
   
   
   
   
   
   
   
   Firmware ESP32 com DHT11 e Modbus TCP

Usa as bibliotecas:

    DHT.h (Adafruit)

    ModbusIP_ESP8266 (funciona no ESP32)

    WiFi.h


    #include <WiFi.h>
#include <ModbusIP_ESP8266.h>
#include <DHT.h>

#define DHTPIN 4
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

ModbusIP mb;

const uint16_t IR_TEMP = 0;
const uint16_t IR_HUMID = 1;
const uint16_t IR_ALARM = 2;
const uint16_t HR_LIMIT_TEMP = 10;
const uint16_t HR_LIMIT_HUMID = 11;

bool alarm = false;
unsigned long lastRead = 0;

void setup() {
  Serial.begin(115200);
  WiFi.begin("SEU_SSID", "SUA_SENHA");
  while (WiFi.status() != WL_CONNECTED) delay(500);

  dht.begin();
  mb.server();
  mb.addIreg(IR_TEMP, 0);
  mb.addIreg(IR_HUMID, 0);
  mb.addIreg(IR_ALARM, 0);
  mb.addHreg(HR_LIMIT_TEMP, 300);
  mb.addHreg(HR_LIMIT_HUMID, 700);
}

void loop() {
  mb.task();

  if (millis() - lastRead > 2000) {
    lastRead = millis();
    float t = dht.readTemperature();
    float h = dht.readHumidity();

    int t10 = isnan(t) ? 0 : round(t * 10);
    int h10 = isnan(h) ? 0 : round(h * 10);

    mb.Ireg(IR_TEMP, t10);
    mb.Ireg(IR_HUMID, h10);

    uint16_t limT = mb.Hreg(HR_LIMIT_TEMP);
    uint16_t limH = mb.Hreg(HR_LIMIT_HUMID);
    alarm = (t10 >= limT) || (h10 >= limH);
    mb.Ireg(IR_ALARM, alarm ? 1 : 0);

    Serial.printf("Temp: %.1f°C | Hum: %.1f%% | Alarm: %s\n", t, h, alarm ? "ON" : "OFF");
  }
}


// Modbus Mapping:
// Ireg[0] = Temperatura x10
// Ireg[1] = Umidade x10
// Ireg[2] = Alarme lógico
// Hreg[10] = Limite temperatura x10
// Hreg[11] = Limite umidade x10
